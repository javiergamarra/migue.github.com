--- 
layout: post
name: scala-implicits-i
title: Scala implicits (I)
time: 2012-02-20 18:23:00 +01:00
---
<div style="text-align: justify;">Durante numerosas entradas hemos estado hablando del lenguaje de programación Scala, analizando algunas de sus principales características y/o la interacción con otros lenguajes: conceptos básicos, traits, parser combinators, combinando AspectJ y Scala, . . . Podéis encontrar todas las entradas relacionadas en el siguiente enlace:&nbsp;<a href="http://miguelinlas3.blogspot.com/search/label/Scala">http://miguelinlas3.blogspot.com/search/label/Scala</a>&nbsp;y un pequeño documento en el que se realiza una somera introducción al lenguaje:&nbsp;<a href="https://github.com/migue/blog-examples/tree/master/scala-intro">https://github.com/migue/blog-examples/tree/master/scala-intro</a></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Durante las siguientes entradas me gustaría ahondar en algunas características más "avanzadas" del lenguaje como "<span style="font-family: 'Courier New', Courier, monospace;">type parametrization</span>", "<span style="font-family: 'Courier New', Courier, monospace;">abstract members</span>" o "<span style="font-family: 'Courier New', Courier, monospace;">implicitis</span>" (estás últimas las abordaremos durante la entrada que nos ocupa).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">El principal problema que se nos presenta cuando trabaja mos con una librería de terceros es la dificultad de extender y/o modificar el comportamiento de la misma. A lo largo de los diferentes lenguajes existentes podemos encontrar numerosas alternativas, cada una con sus ventajas e inconvenientes, como las&nbsp;<span style="font-family: 'Courier New', Courier, monospace;">open classes de Ruby</span> o el <span style="font-family: 'Courier New', Courier, monospace;">ExpandoMetaclass de Groovy</span>.<br /><br />La respuesta de Scala al problema que nos ocupa son los <span style="font-family: 'Courier New', Courier, monospace;">implicits</span>. El compilador intentará incluir en nuestro código fuente aquellos <span style="font-family: 'Courier New', Courier, monospace;">implicits</span> que se encuentren disponibles con el objetivo de solventar cualquier "<i>problema de tipos</i>". De manera general, se rigen por las siguientes reglas:<br /><br /><ul><li>Sólo estarán disponibles para el compilador aquellas definiciones que nosotros marquemos de manera explícita como <span style="font-family: 'Courier New', Courier, monospace;">implicit</span>.</li></ul><ul><li>Los <span style="font-family: 'Courier New', Courier, monospace;">implicits</span> deben estar disponibles en el ámbito de uso.</li></ul><ul><li>El compilador solamente intentará incluir un <span style="font-family: 'Courier New', Courier, monospace;">implicit</span> de cada vez</li></ul><ul><li>El compilador no reemplazará código correcto.</li></ul><ul><li>¿Dónde se utilizan los&nbsp;<span style="font-family: 'Courier New', Courier, monospace;">implicits</span>?</li><ul><li>Conversiones a un tipo determinado</li><li>Conversiones del objeto que recibe la llamada a un método</li><li>Parámetros de funciones</li></ul></ul><div>Hemos visto una pequeña introducción sobre la teoría de los <span style="font-family: 'Courier New', Courier, monospace;">implicits</span> en Scala,&nbsp;las reglas que rigen el funcionamiento de los mismo y&nbsp;las aproximaciones que otros lenguajes utilizan. Puede que con este contenido la entrada se quede un poquito escueta pero he preferido dividirlo en dos entradas independientes por lo que en el próximo post realizaremos un ejemplo práctico y veremos las aplicaciones reales de esta potente (y a veces compleja) funcionalidad que el lenguaje nos brinda.</div><div><br /></div><div>Hasta pronto!</div><div><br /></div><div>Migue</div></div><div class="blogger-post-footer"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/35092134-7899226937106947259?l=miguelinlas3.blogspot.com' alt='' /></div>
