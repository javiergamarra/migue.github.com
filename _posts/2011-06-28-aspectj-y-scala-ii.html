--- 
layout: post
name: aspectj-y-scala-ii
title: AspectJ y Scala (II)
time: 2011-06-28 00:11:00 +02:00
---
<div style="text-align: justify;">En <a href="http://miguelinlas3.blogspot.com/2011/06/aspectj-y-scala-i.html">la entrada anterior</a> analizamos algunas de las similitudes y diferencias existentes entre Scala y AspectJ, llevando a cabo una implementación de una caché extremadamente simple en ambos lenguajes, describiendo las ventajas y desventajas presentes en cada una de las aproximaciones.&nbsp;Durante esta entrada analizaremos un ejemplo de aplicación de una funcionalidad transversal como la gestión de transacciones.&nbsp;</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">El ejemplo que aquí nos ocupa no persigue realizar una implementación detallada de control de transacciones sino simplemente ilustrar como podríamos aplicar una funcionalidad transversal mediante el uso de AspectJ o Scala.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Del mismo modo que en el post anterior, comenzamos por la aproximación basada en AspectJ. Para ello en primer lugar definimos una simple anotación que nos sirva como elemento de marcado de aquellas clases y/o métodos que se deben ejecutar bajo un contexto transaccional.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Una vez definida la anotación anterior definiremos un aspecto que sea capaz de detectar aquellos joint point en los que deseamos establecer un contexto transaccional.&nbsp;</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"></div><div class="p1"><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><i><span class="s1">pointcut</span> transactionalOperation() : <span class="s1">execution</span>(<span class="s2">@Transactional</span> * * (..) );</i></span></div><div class="p1"><br /></div><div class="p1">Con el pointcut anterior estaremos capturando las llamadas realizadas sobre cualquier método anotado con nuestra anotación @Transactional. Ahora necesitaremos definir un advice en el que llevamos a cabo la gestión de la transacción (nótese que este gestor de transacciones es completamente absurdo y simplemente imprime por pantalla la funcionalidad real que debería ser llevada a cabo por un gestor de transacciones operativo)</div><div class="p1"><br /></div><script src="http://pastie.org/2103676.js"></script><br /><div class="p1">En muchas ocasiones todos los métodos de una clase necesitarán ser transaccionales, y no querremos anotar todos los métodos de dicha clase. En este supuesto podríamos utilizar <b>anotaciones a nivel de clase</b> que nos permitan seleccionar aquellos métodos que deseemos (por ejemplo, todos los métodos públicos).<br /><br />Adicionalmente, podríamos hacer uso de los ITD y establecer la transaccionalidad a todas aquellas clases &nbsp;que nosotros deseemos. Por ejemplo, supongamos que todos los nombres de nuestros servicios, los cuales deseamos que sean transaccionales, terminan con el sufijo Service. Podríamos, mediante el uso de un aspecto, añadir la anotación @Transactional a todos nuestros servicios.<br /><br /><div class="p1"><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><span class="s1">declare</span> <span class="s1">@type</span> : *Service : <span class="s2">@Transactional</span> ;</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace; font-size: x-small;"><br /></span></div>Dicho aspecto, en conjunción con el anterior, provocaría que todos nuestros servicios fueran transaccionales<br /><br />En Scala, de nuevo, haremos uso de funciones de alto nivel (high order functions) de manera muy similar a la solución de la caché descrita en la entrada anterior:</div><div><script src="http://pastie.org/2131238.js"></script></div><br />Si deseamos que un método de uno de nuestros servicios sea transaccional no tendremos más que extender de la clase abstracta y utilizar la HOF anterior:<br /><div><script src="http://pastie.org/2131252.js"></script></div><br />Si comparamos las soluciones aportadas por cada una de las dos alternativas tendremos que<br /><ul><li>En el caso de AspectJ no necesitamos anotar cada método de manera independiente puesto que podríamos hacer uso de anotaciones a nivel de clase. El nivel de granularidad que podemos alcanzar está definido a nivel de método (aunque tampoco es un problema excesivamente grande puesto que podríamos utilizar el patrón Extract Method para extraer la funcionalidad transaccional a un método sobre el cual podríamos aplicar nuestro aspecto).</li><li>En el caso de Scala necesitaremos recubrir nuestra lógica con la HOF definida en nuestro ejemplo anterior. En esta situación, el nivel de granularidad es notablemente superior puesto que podemos recubrir una simple parte de nuestro método</li></ul>Durante esta segunda entrada hemos vuelto a confrontar Scala y AspectJ a la hora de aplicar una funcionalidad transversal, intentando plasmar las ventajas y desventajas de cada uno de ellos.<br /><br />En la siguiente y última entrada de esta serie analizaremos cómo aunar lo mejor de ambos mundos en un ejemplo práctico que nos sirva como base para futuros ejemplos.<br /><br />Como siempre podéis encontrar el código fuente de todos los ejemplos del blog (o casi todos :) ) en mi cuenta de <a href="https://github.com/migue/blog-examples">GitHub</a>, bajo el proyecto blog-examples.<br /><br />Hasta pronto!<br /><br />PD: perdón por el ladrillo de entrada :(.<div class="blogger-post-footer"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/35092134-5786380563802065443?l=miguelinlas3.blogspot.com' alt='' /></div>
