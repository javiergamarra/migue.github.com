--- 
layout: post
name: parser-combinators-un-poco-de-teoria
title: "Parser Combinators: un poco de teor\xC3\xADa"
time: 2011-03-30 00:02:00 +02:00
---
<div style="text-align: justify;">Puede que en algunas ocasiones os hayais tenido que enfrentar con la necesidad de escribir un pequeño lenguaje que realice una tarea muy concreta (profundizaremos en el tema de los DSLs en un post futuro): como, por ejemplo, procesar determinados archivos de configuración de vuestra aplicación o la definición de interfaces de usuario de manera sencilla.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Independientemente de las razones por las que estamos desarrollando este componente, necesitaremos un parser que nos ayude a transformar el lenguaje de entrada en una estructura de datos que nuestro programa pueda comprender y procesar. Algunas de las alternativas que se nos plantean son:</div><div style="text-align: justify;"></div><ul><li><b>Escribir nuestro propio parser</b> (conllevaría escribir también el analizador léxico). Si no somos expertos en la materia estaremos enfrentándonos a una tarea relativamente complicada.</li></ul><ul><li><b>Utilizar herramientas para la generación de parsers como Antlr,Bison o JavaCC</b> entre otras muchas. En este caso la dificultad estriba en la necesidad de aprender a manejar una nueva herramienta/lenguaje e integrarlo en nuestro desarrollo y ecosistema.</li></ul><div style="text-align: justify;">Durante esta entrada, y posiblemente la siguiente, vamos a presentar un enfoque alternativo a las dos opciones anteriores. En lugar de utilizar un DSL externo como podría ser el ofrecido por Antlr, vamos a utilizar un DSL interno. Dicho DSL estará formado por <b>parser combinators</b> (funciones y operadores definidos en Scala que servirán como base para la construcción de nuestros futuros parsers).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Siendo originales :), imaginemos que deseamos cosntruir un parser de expresiones aritméticas de números enteros. En primer lugar, definamos la gramática de nuestro lenguaje:</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><div style="text-align: justify;"><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace; font-size: x-small;">expr &nbsp;::=&nbsp;term {"+" term | "-" term}.&nbsp;</span></div><div style="text-align: justify;"><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace; font-size: x-small;">term &nbsp;::=&nbsp;factor {"*" factor | "/" factor}.</span></div><div style="text-align: justify;"><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace; font-size: x-small;">factor &nbsp;::=&nbsp;&nbsp;integer | "(" expr ")".</span></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">El fragmento de código anterior representa una gramática libre de contexto (no vamos a profundizar en este tema porque tendríamos que escribir miles de posts) que modela nuestro lenguaje de expresiones aritméticas de números enteros. ¿Y ahora?</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Una vez definida la gramática anterior hemos llevado a cabo la tarea más complicada de todas. Si utilizais los <b>parser combinators</b> ofrecidos por Scala tendremos casi todo el trabajo sucio realizado. A modo de ejemplo:</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><div style="text-align: justify;"><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace; font-size: x-small;">import scala.util.parsing.combinator._</span></div><div style="text-align: justify;"><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace; font-size: x-small;"><br /></span></div><div style="text-align: justify;"><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace; font-size: x-small;">class IntegerArithmetics extends JavaTokenParsers {</span></div><div style="text-align: justify;"><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace; font-size: x-small;">&nbsp; &nbsp;def expr: Parser[Any] = term~rep("+"~term | "-"~term)</span></div><div style="text-align: justify;"><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace; font-size: x-small;">&nbsp; &nbsp;def term: Parser[Any] = factor~rep("*"~factor | "/"~factor)</span></div><div style="text-align: justify;"><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace; font-size: x-small;">&nbsp; &nbsp;def factor: Parser[Any] = integer | "("~expr~")"</span></div><div style="text-align: justify;"><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace; font-size: x-small;">}</span></div><div><br /></div></div><div style="text-align: justify;">Si comparamos el código Scala con la definición en notación EBNF de nuestra gramática observaremos que podríamos inferir nuestro código fuente Scala sin más que realizar una serie de reemplazos en nuestra notación EBNF:</div><div style="text-align: justify;"><ol><li>Cada regla se convierte en un método por lo que tendremos que prefijarlas con <b>def</b>.</li><li>El tipo de retorno de cada uno de los métodos anteriores es <b>Parser[Any]</b>&nbsp;(veremos en la siguiente entrada que significa esto) por lo que tendremos que cambiar el símbolo "<b>::=</b>" por "<b>:Parser[Any] =</b>"</li><li>Insertar el símbolo ~ entre todos los elementos de cada una de las reglas (en la notación EBNF esto es implícito)</li><li>La repetición se refleja mediante el uso de <b>rep(...)</b> en lugar de <b>{...}</b></li><li>El punto al final de cada regla no es necesario (podríamos poner ; si lo deseamos)</li></ol></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Esto no ha sido más que una toma de contacto con el mundo de los parser combinators en Scala. En la siguiente entrada descubriremos cómo realizar construcciones más complejas, formatear la salida de manera que podamos construir las estructuras de datos requeridas para nuestro procesamiento o ejecutar nuestros parsers.&nbsp;</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Para todo ello diseñaremos y construiremos un pequeño parser que nos permita analizar el bytecode de la máquina virtual una vez desemsamblado (para los más inquietos <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace; font-size: x-small;">javap -v ClassFile</span> (sin .class))</div></div><div class="blogger-post-footer"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/35092134-588477828125944448?l=miguelinlas3.blogspot.com' alt='' /></div>
