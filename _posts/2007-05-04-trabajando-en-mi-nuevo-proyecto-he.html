--- 
layout: post
name: trabajando-en-mi-nuevo-proyecto-he
title: 
time: 2007-05-04 18:46:00 +02:00
---
<div style="text-align: justify;">Trabajando en mi nuevo proyecto he tenido la oportunidad de retomar el trabajo con mi lenguaje de programación favorito (alguna chapuzilla tengo hecha pero en plan personal) y de poder aplicar mis escasos conocimientos en el desarrollo del mismo.<br /><br />Aunque el párrafo anterior no era precisamente lo que tenía pensado contaros aunque me viene perfecto para introducir el "problema" que pretendía ilustrar:<br /><br />Muchas veces cuando estamos desarrollando nuestras aplicaciones utilizamos asertos o similares para determinar errores. El problema de estas soluciones radica en que la mayoría de ellas son en tiempo de ejecución (dejar constancia que yo también lo hacía así :D). Un buen "chequeo estático" y mensajes de error configurables y explicativos son necesarios, sobre todo desde que la programación genérica se lleva cada vez más en el lenguaje C++. A continuación os propongo una pequeña utilidad para detectar errores en tiempo de compilación (con los consiguientes beneficios que ello conlleva).<br /><br />Como bien os estareis imaginando la idea no es mía.(sinceramente ahora mismo no recuerdo si la idea original la leí en un artículo o en un libro de Alexandrescu). Vamos allá:<br /><br />En primer lugar definamos una plantilla de clase del siguiente modo:<br /><br /><span style="font-family: courier new; font-weight: bold; color: rgb(51, 102, 255);">template <bool> struct Checker{</span><br /><span style="font-family: courier new; font-weight: bold; color: rgb(51, 102, 255);">     Checker(...);</span><br /><span style="font-family: courier new; font-weight: bold; color: rgb(51, 102, 255);">};</span><br /><br /><br />A continuación hagamos una especialización parcial de la plantilla anterior:<br /><br /><span style="font-family: courier new; font-weight: bold; color: rgb(51, 102, 255);">template <> struct Checker<false> { };</span><br /><br />Vamos a aprovecharnos del preprocesador para construir mensajes de error configurables<br /><br /><span style="font-family: courier new; font-weight: bold; color: rgb(51, 102, 255);">#define CHECKING_ESTATICO(expresion, mensaje) \</span><br /><span style="font-family: courier new; font-weight: bold; color: rgb(51, 102, 255);">  {\</span><br /><span style="font-family: courier new; font-weight: bold; color: rgb(51, 102, 255);">    class ERROR_##mensaje{};\</span><br /><span style="font-family: courier new; font-weight: bold; color: rgb(51, 102, 255);">    (void)</span><span style="font-family: courier new; font-weight: bold; color: rgb(255, 0, 0);">sizeof</span><span style="font-family: courier new; font-weight: bold; color: rgb(51, 102, 255);">(Checker<(expresion)!= 0>((ERROR_##mensaje()))); \</span><br /><span style="font-family: courier new; font-weight: bold; color: rgb(51, 102, 255);">  }</span><br /><br />¡OJO! No dejar espacios entre el nombre de la macro y los paréntesis<br /><br />Vamos a darle utilidad a este chequeo en tiempo de compilación construyendo una versión "segura" de reinterpret_cast. Imaginaos que nuestro código realiza un reinterpret_cast de un tipo A a un tipo B y que estamos desarrollando nuestro proyecto en una máquina Z (nosotros sabemos que en nuestra máquina de desarrollo el tamaño del tipo A es menor o igual que el tamaño del tipo B). Ahora imaginaros que llevamos nuestro código a una máquina Y en la que no sabemos si el tamaño del tipo A es menor o igual que el tamaño del tipo B ....... ¿que ocurrirá?<br /><br />Para ello desarrollemos, baśandonos en nuestra construcción anterior, una versión segura de reinterpret_cast que nos de un error en TIEMPO DE COMPILACIÓN en caso de que el tipo de destino del casting presente un tamaño menor que el origen. Actuaríamos del siguiente modo:<br /><br /><span style="font-family: courier new; color: rgb(51, 102, 255); font-weight: bold;"><span style="color: rgb(255, 0, 0);">template</span></span><span style="font-family: courier new; color: rgb(51, 102, 255); font-weight: bold;"><typename style="color: rgb(51, 255, 51);">Hacia</span></span><span style="font-family: courier new; color: rgb(51, 255, 51); font-weight: bold;"></span><span style="font-family: courier new; color: rgb(51, 102, 255); font-weight: bold;">, typename </span><span style="font-family: courier new; color: rgb(51, 255, 51); font-weight: bold;">Desde</span><span style="font-family: courier new; color: rgb(51, 102, 255); font-weight: bold;"><span style="color: rgb(51, 255, 51);"></span>></span><br /><span style="font-family: courier new; color: rgb(51, 102, 255); font-weight: bold;">Hacia reinterpret_cast_modo_seguro(</span><span style="font-family: courier new; color: rgb(51, 255, 51); font-weight: bold;">Desde</span><span style="font-family: courier new; color: rgb(51, 102, 255); font-weight: bold;"> d){</span><br /><br /><span style="font-family: courier new; color: rgb(51, 102, 255); font-weight: bold;">CHECKING_ESTATICO(</span><br /><span style="font-family: courier new; color: rgb(51, 102, 255); font-weight: bold;">            <span style="color: rgb(255, 0, 0);">sizeof</span>(Desde) <= </span><span style="font-family: courier new; color: rgb(51, 102, 255); font-weight: bold;"><span style="color: rgb(255, 0, 0);">sizeof</span></span><span style="font-family: courier new; color: rgb(51, 102, 255); font-weight: bold;"><span style="color: rgb(255, 0, 0);"></span>(Hacia),</span><br /><span style="font-family: courier new; color: rgb(51, 102, 255); font-weight: bold;">            Destino_Demasiado_Pequenio</span><br /><span style="font-family: courier new; color: rgb(51, 102, 255); font-weight: bold;">            );</span><br /><span style="font-family: courier new; color: rgb(51, 102, 255); font-weight: bold;">  <span style="color: rgb(255, 0, 0);">return reinterpret_cast</span><hacia>(d);</span><br /><span style="font-family: courier new; color: rgb(51, 102, 255); font-weight: bold;">}</span><br /><br />Podríamos utilizar esta función del mismo modo en que usamos reinterpret_cast.<br /><br />Como podeis ver esto no es más que una ligera idea de como podemos usar los templates y el preprocesador para detectar errores en tiempo de compilación y enviar mensajes más o menos descriptivos. Podríamos construir, con poco trabajo, más funciones similares a la anterior que nos pueden resultar útiles (con la ayuda de la macro CHECKER).<br /><br />Creo que esto es mucho más difícil explicarlo que entenderlo jejejje. Espero que os sirva de algo (posiblemente no pero así al menos he pasado la tarde que no me apetecía trabajar en mi fin de carrera).<br /><br />Hasta pronto!<br />Un abrazo!<br /><br />PD: creo que como mejor se entiende la macro CHECKER es mirando el código que genera el preprocesador. Suponiendo que tenemos el código fuente en el fichero tricks.cc, si queremos ver que código se genera una vez preprocesada la directiva #define no tenemos más que ejecutar la siguiente orden:<br /><br /><div style="text-align: center;"><span style="font-weight: bold; font-style: italic; font-family: courier new;">$> gcc -E -o tricks.i tricks.cc</span><br /></div><br />La orden anterior crea el fichero tricks.i con el código generado por el preprocesador.</div><div class="blogger-post-footer"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/35092134-7284531230745127185?l=miguelinlas3.blogspot.com' alt='' /></div>
