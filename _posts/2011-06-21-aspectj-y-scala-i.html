--- 
layout: post
name: aspectj-y-scala-i
title: AspectJ y Scala (I)
time: 2011-06-21 00:09:00 +02:00
---
<div style="text-align: justify;">¿Podemos establecer alguna conexión entre estos dos mundos? Si nos detenemos por un instante veremos que comparten muchas más cosas de las que a simple vista podría parecer:</div><div style="text-align: justify;"></div><ul><li>Son lenguajes de tipado estático.</li><li>Ambos producen código compatible con la máquina virtual de Java (JVM)</li><li>Las funciones de alto nivel de Scala comparten algunas características con los advices de AspectJ</li><li>Los traits de Scala comparten algunas características con el static crosscuting de AspectJ.</li></ul><br /><div style="text-align: justify;">Durante el resto de la entrada que nos ocupa (y la siguiente) realizaremos una pequeña comparativa en la que pondremos de manifiesto el modo en que cada uno de estos lenguajes resuelve determinado tipo de problemas. Pongámonos manos a la obra.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><span class="Apple-style-span" style="font-size: large;"><b>Cachés</b></span></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">A través de este ejemplo se pretende presentar el modo en que ambos lenguajes solucionan el problema de aplicar una funcionalidad transversal en un punto determinado del código. Implementaremos un mecanismos de caché extremadamente sencillo de manera que podamos centrar nuestra atención en los aspectos relevantes de las alternativas que estamos planteando</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">En el caso de AspectJ se está tendiendo a utilizar las anotaciones como un elemento de marcado (y parece que está siendo recibido con una aceptación más que notable). Nuestro primer paso será definir la anotación con la que realizaremos el "marcado" de aquellos métodos que deseamos establecer como cacheados:</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"></div><div class="p1"><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><b><span class="s1">@Retention</span>(RetentionPolicy.<span class="s2">RUNTIME</span>)</b></span></div><div class="p2"><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><b>public<span class="s3"> </span>@interface<span class="s3"> </span><span class="s1">Cachable</span><span class="s3"> {</span></b></span></div><div class="p1"><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><b><span class="Apple-tab-span"></span>&nbsp; &nbsp;String scriptKey () <span class="s4">default</span> <span class="s5">""</span>;</b></span></div><div class="p1"><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><b>}</b></span></div><br /><div style="text-align: justify;"><br /></div><div style="text-align: justify;">El atributo keyScript de la anotación anterior actuaría (en una caché real), como un pequeño lenguaje de scripting de manera que pudiera ser evaluado por la caché para generar la clave bajo la que se almacenará una determinada llamada (obviaremos esta parte para intentar no distraernos de nuestro principal objetivo).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Una vez definido el elemento de marcado, definiremos nuestro aspecto, el cual será capaz de capturar las llamadas de aquellos métodos anotados con @Cacheable y realizar la lógica necesaria de nuestra sencilla caché</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;" width="10%"><script src="http://pastie.org/2074516.js"></script></div><br /><div style="text-align: justify;">En el caso de Scala llevaremos a cabo nuestra funcionalidad transversal mediante el uso de funciones de primer nivel (high order functions)</div><div style="text-align: justify;"><script src="http://pastie.org/2098190.js"></script></div><br />Gracias a la funcionalidad anterior, podemos pasar al método cache una función que será ejecutada en caso de ser necesario, devolviendo los valores de la caché en el supuesto de que haya sido calculado en un paso anterior.<br /><br />Si comparamos las dos alternativas que hemos planteado hasta este momento:<br /><ul><li>En el caso de AspectJ, cada uno de los elementos que deseamos cachear tendremos que anotarlos con, valga la redundancia, la anotación que hemos definido anteriormente. Mientras tanto, en el caso de Scala, tendremos que recubrir cada uno de los métodos que deseamos cachear con la función de alto nivel (high order function).</li></ul><ul><li>En el caso de AspectJ estamos utilizando un "lenguaje" externo que actua como elementos de las claves de nuestra caché mientras que en el caso de Scala estamos utilizando el propio lenguaje de manera nativa, con el consiguiente beneficio que ello conlleva.</li></ul><div style="text-align: justify;">Esta ha sido nuestra primera aproximación a Scala y AspectJ. Durante las siguientes entradas analizaremos algunos ejemplos adicionales y veremos como podemos integrar lo mejor de ambos mundos.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Podéis encontrar el código fuente de los ejemplos anteriores en el siguiente repositorio de <a href="https://github.com/migue/blog-examples/">GitHub</a>, concretamente en los proyectos AspectJCacheExample y ScalaCacheExample.<br /><br />Hasta pronto!</div><blockquote><ul></ul></blockquote><div class="blogger-post-footer"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/35092134-7488054958529463701?l=miguelinlas3.blogspot.com' alt='' /></div>
