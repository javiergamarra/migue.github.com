--- 
layout: post
name: continuacin-veremos-unos-pequeos-y-muy
title: 
time: 2007-07-27 23:26:00 +02:00
---
<div style="text-align: justify;">A continuación veremos unos pequeños ( y muy sencillos) ejemplos de uso de algunos de los algoritmos de la librería STL. No soy ni mucho menos un experto pero creo que pueden servir de ayuda si alguien quiere iniciarse en la programación genérica.<br /><br />En primer lugar definamos un problema; chorras claro está, aunque servirá para nuestros didácticos propósitos. Imaginemos que estamos desarrollando una aplicación que situa puntos en un plano, es decir, nos indica la posición que los objetos tendrían en un mapa. Además supongamos que se nos presenta el problema de determinar si un determinado punto está contenido en una colección de coordenadas determinada. Vamos a resolver este sencillo problema utilizando la librería STL. Comenzemos:<br /><br />En primer lugar seleccionamos la utilidad<span style="font-weight: bold;"> std::pair<int,int></span> como reprentación de las coordenadas en el plano. Definimos un typedef para no tener que teclear todo el tipo anterior. Algo como lo que sigue:<br /><br /><div style="text-align: center;"><span style="font-family: courier new;">typedef std::pair<int,int> COORDENADA_PLANO;</span><br /><br /><div style="text-align: justify;">Definamos ahora una colección de puntos en el plano:<br /><br /><div style="text-align: center;"><div style="text-align: justify;"><span style="color: rgb(204, 0, 0);"> //! 1. Vector de puntos del plano</span><span style="font-family: courier new;"><span style="color: rgb(204, 0, 0);">   </span>           <br />    std::vector<coordenada_plano> puntos;</span><br /></div><div style="text-align: justify;"><span style="font-family: courier new;">    puntos.push_back(std::make_pair<int,int>(1,1));</span><br /><span style="font-family: courier new;">    puntos.push_back(std::make_pair<int,int>(-1,1));</span><br />    puntos.push_back(std::make_pair<int,int>(3,1));<br />    puntos.push_back(std::make_pair<int,int>(1,3));<br />    puntos.push_back(std::make_pair<int,int>(2,1));<br />    puntos.push_back(std::make_pair<int,int>(1,-2));<br />    puntos.push_back(std::make_pair<int,int>(3,8));<br />    puntos.push_back(std::make_pair<int,int>(1,1));<br />    puntos.push_back(std::make_pair<int,int>(1,1));<br />    puntos.push_back(std::make_pair<int,int>(3,8));<br /><br />También podríamos rellenar el vector anterior del siguiente modo (con número pseudo-aleatorios)<br /><br />    std::fill(puntos.begin(),puntos.end(),std::make_pair<int,int>(rand(),rand()));<br /><br />La función anterior aplica, desde el comienzo [ begin() ] hasta el final del vector [ end() ], a cada uno de los elementos la función std::make_pair. El functor que se pasa como tercer argumento a este algortimo no espera argumentos.<br /><br />Pensemos ahora que queremos comparar el punto (3,8) con el la colección de puntos definida en el paso anterior; y que además queremos que dicho puntos nos queden almacenados en otra estructura de datos, por ejemplo,en otro vector. Una posible solución,entre la multitud de ellas que podríamos aplicar, es la siguiente:<br /><br /><span style="color: rgb(204, 0, 0);">    //2. Vector de puntos que coindicen con A</span><br />    std::vector<coordenada_plano> match;<br />   std::remove_copy_if(puntos.begin(),<br />                            puntos.end(),std::back_inserter(match),<br />                            std::bind2nd(AreDistinct(),A));<br /><br />En un principio puede parecer complicado pero ya vereis como es muy sencillo:<br /><br />El algortimo std::remove_copy_if(...) copia aquellos elementos comprendidos en el intervalo [begin,end) al rango comenzado por match, salvo aquellos elementos para los que AreDistinct retorna cierto. Necesitamos un par de artifactos más:<br /><br /><ol><li>Dado que en un principio no sabemos cuantos elementos coincidiran con A declaramos un iterador de tipo std::back_inserter sobre nuestro vector destino match. De este modo cada coincidencia que el algoritmo encuentre será colocada tras la última.</li><li>El algoritmo itera por toda la colección de puntos, y le aplica el functor AreDistinct. Dicho functor espera dos argumentos: el que le pasa el algoritmo en cada una de las iteraciones y el que nosotros queremos comparar con el resto de la colección. Necesitamos hacer un "binding" del segundo argumento: para ello actuamos del siguiente modo: std::bind2nd(AreDistinct(),A) con lo que estamos "forzando" que cada uno de los elementos del vector puntos se compare con A.</li></ol>Finalmente, si imprimiésemos el resultado de una ejecución con una instrucción parecida a esta:<br />    std::for_each(match.begin(),match.end(),Print_Coordenada(std::cout));<br /><br />Obtendríamos que los puntos (3,8) y (3,8) coindicen con el punto A=(3,8). Como bien se  observa en el código esos dos puntos son los únicos idénticos al punto A.<br /><br />En el directorio que teneis a la derecha podeis descargaros los fuentes completos del ejemplo (ya vereis que es muy sencillo). Está en la carpeta CodeAndExamples, en el subdirectorio STL; es el archivo algorithms-1.tgz.<br /><br />Hasta mañana!<br /></div></div></div></div></div><div class="blogger-post-footer"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/35092134-4880970922813177557?l=miguelinlas3.blogspot.com' alt='' /></div>
