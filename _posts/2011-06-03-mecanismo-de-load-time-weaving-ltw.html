--- 
layout: post
name: mecanismo-de-load-time-weaving-ltw
title: Mecanismo de Load Time Weaving (LTW)
time: 2011-06-03 21:47:00 +02:00
---
<div style="text-align: justify;">Durante la <a href="http://miguelinlas3.blogspot.com/2011/05/weaving-en-aspectj-i.html">última entrada</a> analizábamos de manera introductoria los diferentes mecanismos de tejido ofrecidos por AspectJ así como las principales características de los mismos. Durante esta entrada nos acercaremos un poquito más al mecanismo de tejido en tiempo de carga, por normal general más desconocido, desde mi punto de vista, que el mecanismo de tejido en tiempo de construcción (durante todos los ejemplos que hemos visto en anteriores entradas siempre hemos utilizado el tejido en tiempo de construcción).<br /><br />Los pasos que tenemos que seguir cuando utilizamos el tejido en tiempo de carga son los siguientes:<br /><br /><ul><li>Iniciar nuestra aplicación con el archivo aspectjweaver.jar el actuando como un agente (hablaremos de agentes en otra entrada). Para ello podríamos utilizar una línea como la siguiente</li></ul><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace; font-size: x-small;"><div style="text-align: center;">java -javaagent:<path>/aspectjweaver.jar <more options=""> <mainclass></mainclass></more></path></div></span><ul><li>Durante el proceso de inicialización del agente (llevado a cabo por la máquina virtual) el propio agente recupera aquellos archivos existentes en el classpath que coincidan con META-INF/aop.xml (en el caso de encontrar múltiples llevará a cabo la combinación de los mismos).</li></ul><ul><li>Carga de los aspectos indicados.</li></ul><ul><li>El agente se registra como un listener del evento de carga de clases de la máquina virtual. Mediante este mecanismo se tiene acceso a la definición de la clase, permitiendo incluso la modificación de la misma.</li></ul><ul><li>Continua el proceso normal de carga de nuestro aplicación.</li></ul><ul><li>Cada vez que una nueva clase es cargada la máquina virtual notifica al agente dicha situación. En ese momento es posible examinar la clase en cuestión y determinar si algunos de los aspectos cargados con anterioridad necesita ser tejido. En caso afirmativo, la clase será tejida con el aspecto en cuestión, retornando el bytecode resultante a la máquina virtual.</li></ul><ul><li>La máquina virtual utiliza el bytecode resultante como elemento de definición de la clase.</li></ul></div><div style="text-align: justify;">Mediante el conjunto de pasos anteriores, aquellas clases que hayan hecho matching con las definiciones de nuestros aspectos tendrán incorporada la funcionalidad definida en éstos últimos.<br /><br />El agente anterior utiliza un interfaz de la máquina virtual conocido como <a href="http://download.oracle.com/javase/1.5.0/docs/guide/jvmti/jvmti.html">JVMTI</a> (Java Virtual Machine Tools Interface) que ha sido introducido a partir de Java 5. En el caso de que utilicéis una versión anterior podréis hacer uso de este mecanismo mediante una versión basada en classloaders específicos.</div><div style="text-align: justify;"><br /></div><div class="blogger-post-footer"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/35092134-7956674576496354795?l=miguelinlas3.blogspot.com' alt='' /></div>
