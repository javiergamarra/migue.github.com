--- 
layout: post
name: aspectj-y-scala-y-iii
title: AspectJ y Scala (y III)
time: 2011-06-29 18:31:00 +02:00
---
<div style="text-align: justify;">Última entrada (en esta ocasión mucho menos ladrillo) de esta mini-comparativa que estamos llevando a cabo entre AspectJ y Scala (podéis consultar las anteriores entradas en los siguientes enlaces: <a href="http://miguelinlas3.blogspot.com/2011/06/aspectj-y-scala-i.html">AspectJ y Scala (I)</a>, <a href="http://miguelinlas3.blogspot.com/2011/06/aspectj-y-scala-ii.html">AspectJ y Scala (II)</a>.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Hemos estado revisando cómo llevar a cabo la aplicación de varias funcionalidades como el uso de cachés o la gestión de transacciones mediante el uso de AspectJ y Scala, haciendo hincapié en las ventajas y desventajas de las dos aproximaciones. Nótese que hemos estado hablando de funcionalidad transversal como las transacciones y la caché pero no hemos hablado de otro tipo de funcionalidades las cuales abarcan un espectro mucho más amplio como por ejemplo FFDC (First Faiulure Data Capture), Profiling, gestión de la concurrencia, etc. En este tipo de situaciones el uso de Scala y HFOs resultaría mucho más tedioso que los ejemplos vistos en las entradas anteriores; derivando en los síntomas clásicos de funcionalidad "difuminada" por toda nuestra apliación.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">¿Conclusión? El uso de cualquiera de las dos aproximaciones que hemos estado analizando dependerá, como en el 90 por ciento de todas las situaciones, del problema que estemos resolviendo, por lo que tendremos que escoger la "herramienta" más adecuada para el problema que se nos plantea.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">¿Y por qué no un mixin de las anteriores? Esta es una de las alternativas que más me convence:</div><div style="text-align: justify;"></div><ul><li>Compilamos nuestros programas Scala de la manera habitual.</li></ul><ul><li>Definimos nuestros aspectos para llevar a cabo la funcionalidad transversal deseada.</li></ul><ul><li>Realizamos un proceso de binary weaving (ya sea build time o load time)</li></ul><div>Mediante el mecanismo anterior estaremos aplicando nuestros aspectos a nuestro código Scala compilado.</div><div><br /></div><div>En mi cuenta de <a href="https://github.com/migue/blog-examples">GitHub</a> podréis encontrar dos proyectos Eclipse (<b>scala-simple-service </b>y<b> aspectj-advice-scala</b>) que deben ser utilizados de manera conjunta. Mediante estos dos pequeños proyectos de ejemplo se ilustra cómo podemos utilizar conjuntamente aspectos escritos en AspectJ que hagan advice sobre código Scala compilado.</div><div><br /></div><div>Hasta pronto!</div><div><br /></div><div><br /></div><div class="blogger-post-footer"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/35092134-3957623553885371839?l=miguelinlas3.blogspot.com' alt='' /></div>
