--- 
layout: post
name: primero-de-mayo-es-increible-lo-rpido
title: 
time: 2007-05-01 11:46:00 +02:00
---
Primero de mayo, es increible lo rápido que se me pasa el tiempo últimamente; no sé si será que me estoy haciendo viejo a marchar forzadas o que últimamente tengo bastantes cosas entre manos. Esperemos que sea lo segundo jejejeje.<br /><br /><div style="text-align: justify;">Este finde no he hecho gran cosa, el sábado a la tarde estuve trabajando un rato en mi proyecto y por la tarde salí de compras (aunque no me compré nada ya tengo ojeadas unas zapatillas y alguna que otra cosilla) y el domingo me fui a Salamanca a pasar el día.<br /><br />No tengo muchas cosas que contaros así que voy a aprovechar para comenzar una nueva sección en el blog: el mundo de la programación. Simplemente se trata de algunos ejemplos sencillos basados en mis escasos conocimientos y mi corta experiencia de algunos temas que me gustan o de los que me gustaría aprender. Espero que os guste y/o os pueda servir de ayuda. Vamos allá . . . . . .<br /></div><br /><div style="text-align: justify;">Vamos a comenzar con un post dedicado a los patrones de diseño y el lenguaje de programación C++. Os propongo una implementación del patrón de diseño Singleton (uno de los patrones de diseño más simples aunque creo que muchas veces lo utilizamos de forma no demasiado apropiada).<br /><br />El patrón anterior nos garantiza que, desde el momento en que instanciamos un objeto de dicha clase, será esa la única instancia que exista de dicho objeto. Existen multitud de libros acerca de patrones de diseño y con multitud de aplicaciones de los mismos. Yo desde aquí nada más pretendo dejaros mi experiencia y el uso que yo le he dado en mis aplicaciones. Por ejemplo, este patrón lo he utilizado en el desarrollo de un compilador para representar los <span style="font-style: italic;">builtin type</span>. Manos a la obra:<br /><br />En primer lugar definimos la clase singletonPattern y el método que nos permitira obtener una referencia al mismo (hacemos que el constructor sea privado para que no se puedan crear objetos de ese tipo):<br /><br /><span style="font-weight: bold; color: rgb(51, 102, 255);font-family:courier new;" >class singletonPattern{</span><br /><span style="font-weight: bold; color: rgb(255, 0, 0);font-family:courier new;" >    private:</span><br /><span style="font-weight: bold; color: rgb(51, 102, 255);font-family:courier new;" >          <span style="color: rgb(51, 204, 0);">/// unique instance of the object</span></span><br /><span style="font-weight: bold; color: rgb(51, 102, 255);font-family:courier new;" >          static singletonPattern * instance;</span><br /><span style="font-weight: bold; color: rgb(51, 102, 255);font-family:courier new;" >          <span style="color: rgb(51, 204, 0);">/// Default Constructor</span></span><br /><span style="font-weight: bold; color: rgb(51, 102, 255);font-family:courier new;" >          singletonPattern(){}</span><br /><br /><span style="font-weight: bold; color: rgb(255, 0, 0);font-family:courier new;" >    public:</span><br /><span style="font-weight: bold; color: rgb(51, 204, 0);font-family:courier new;" >          /*!</span><br /><span style="font-weight: bold; color: rgb(51, 204, 0);font-family:courier new;" >            Returns the reference<br />         to the unique instance of the object</span><br /><span style="font-weight: bold; color: rgb(51, 204, 0);font-family:courier new;" >            (if it's the first time create de reference)</span><br /><span style="font-weight: bold; color: rgb(51, 204, 0);font-family:courier new;" >           */</span><br /><span style="font-weight: bold; color: rgb(51, 102, 255);font-family:courier new;" >          static singletonPattern * getInstance(){</span><br /><span style="font-weight: bold; color: rgb(51, 102, 255);font-family:courier new;" >            if(instance == NULL)</span><br /><span style="font-weight: bold; color: rgb(51, 102, 255);font-family:courier new;" >                  instance = new singletonPattern();</span><br /><span style="font-weight: bold; color: rgb(51, 102, 255);font-family:courier new;" >            return instance;</span><br /><span style="font-weight: bold; color: rgb(51, 102, 255);font-family:courier new;" >  }</span><br /><span style="font-weight: bold; color: rgb(51, 102, 255);font-family:courier new;" >};</span><br /><br /><span style="font-weight: bold; color: rgb(255, 0, 0);font-family:courier new;" >// init the static member</span><br /><span style="font-weight: bold; color: rgb(51, 102, 255);font-family:courier new;" >  singletonPattern * singletonPattern :: instance = NULL;</span><br /><br />El código anterior no estaría completo dado que nos queremos asegurar de que nuestra instancia sea única por lo que tendremos que implementar el constructor de copia y el operador de asignación (no tiene sentido el operador de asignación en el singleton) como privados dentro de nuestra clase singletonPattern. Algo como lo que sigue:<br /><br /><span style="font-weight: bold; color: rgb(51, 204, 0);">  /// Copy Constructor</span><br /><span style="color: rgb(51, 102, 255); font-weight: bold;font-family:courier new;" >  singletonPattern(const singletonPattern & sp){}</span><br /><br /><span style="color: rgb(51, 204, 0); font-weight: bold;">  /// Assignement Operator</span><br /><span style="color: rgb(51, 102, 255); font-weight: bold;font-family:courier new;" >  singletonPattern & operator=(singletonPattern &amp; sp){</span><br /><span style="color: rgb(51, 102, 255); font-weight: bold;font-family:courier new;" >    return *this;</span><br /><span style="color: rgb(51, 102, 255); font-weight: bold;font-family:courier new;" >  }</span><br /><br />Si quisieramos utilizar esta clase en uno de nuestros programas no tendríamos más que declarar un objeto tal  y como a continuación se muestra:<br /><span style="color: rgb(51, 102, 255); font-weight: bold;">    </span><span style="color: rgb(51, 102, 255); font-weight: bold;font-family:courier new;" >singletonPattern * singleton = singletonPattern::getInstance();</span><br /><br />Y listo. Con esto tendremos nuestro patrón de diseño Singleton listo para disponer de el cuando deseemos.<br /><br />Desde el siguiente enlace podeis descargaros el código fuente completo junto con un makefile: <a href="http://www.box.net/public/z0u1c2c0ao">singletonPatternC++</a>.<br /><br />El código disponible en el enlace anterior es una primera aproximación. Intentemos añadirle algunas mejoras:<br /><br />   Un primer cambio a realizar sería el de retornar una referencia en lugar de un puntero en el método getInstance(); de este modo evitaríamos que el usuario que obtiene una referencia del objeto intentase aplicarle el operador delete. El prototipo del nuevo método podría ser algo parecido a lo siguiente:<br /><br /><div style="text-align: center;"><span style="font-weight: bold; color: rgb(51, 102, 255);font-family:courier new;" >          static singletonPattern & getInstance();</span><br /></div><br /><br />Pensemos ahora en que ocurre cuando se destruye el singleton.Realmente no se trata un <span style="font-style: italic;">memory leak</span> tradicional sino un <span style="font-style: italic;">resource leak</span>. El singleton podría haber adquirido diversos recursos del operativo como un socket,un semáforo,...... Con el objetivo de solucionar este problema, Scott Meyers facilitó una solución sencilla (y muy elegante): en lugar de almacenar un puntero a un objeto de tipo Singleton su solución instancia una variable local estática del siguiente modo:<br /><br /><div style="text-align: center;"><span style="font-weight: bold; color: rgb(51, 102, 255);font-family:courier new;" >singletonPattern & getInstance(){</span><br /><span style="font-weight: bold; color: rgb(51, 102, 255);font-family:courier new;" >                static </span><span style="font-weight: bold; color: rgb(51, 102, 255);font-family:courier new;" >singletonPattern instance;</span><span style="font-weight: bold; color: rgb(51, 102, 255);font-family:courier new;" ><br />return instance;</span><span style="font-weight: bold; color: rgb(51, 102, 255);font-family:courier new;" ><br />}<br /></span><div style="text-align: justify;">El fragmento anterior se conoce como el singleton de Meyers y se basa en, tal y como describe Alexandrecu en su libro Modern C++ Desing:Generic Programming and Patterns Applied, <span style="font-style: italic; font-weight: bold;">"some compiler magic</span>": un objeto estático de una función es inicializado, en tiempo de ejecución, en el momento de la primera pasada de la definición.<br /><br />Este par de soluciones son, aparentemente sencillas, y pueden ayudarnos a construir un Singleton mucho más robusto.<br /><br />En el libro de Alexandrescu mencionado anteriormente plantea otros problemas tales como las referencias muertas (a las cuales aplica soluciones elegantes e ingeniosas) o los problemas derivados de la interacción de los hilos y los singleton. En futuros post puede que ahondemos un poco en estas cuestiones.<br /><br />Hasta pronto!<br />Un abrazo!</div></div></div><div class="blogger-post-footer"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/35092134-5895486391418709910?l=miguelinlas3.blogspot.com' alt='' /></div>
